//
// Created by lukas on 06.04.19.
//

#ifndef PROJECT_NODESEXPANDER_HPP
#define PROJECT_NODESEXPANDER_HPP

#include "../odesolver/util/header.hpp"
#include "../odesolver/util/dev_dat.hpp"
#include "../odesolver/util/monitor.hpp"
#include "node.hpp"
#include "../odesolver/extern/thrust_functors.hpp"

/** @brief Class for extracting and linearizing the information about parent
 * cube indices per recursive depth per cube for the given nodes. The class
 * allows for a computation of vectors of parent cube indices and a vector of
 * the depth per cube */


class NodesExpander
{
public:
    /** @brief Constructor for extracting information about the cube indices
     * packed in each node and for preparing a computation of the vertices of
     * respective hypercubes in the recursive search tree.
     *
     * @param maximum_depth: Maximum recursive depth of the provided nodes
     * @param number_of_nodes: Expected number of provided nodes
     */
    NodesExpander(
        const int maximum_depth,
        const int number_of_nodes
    );

    /** @brief Extracts based on the provided nodes information about the cube
     * indices of hypercubes in the recursive search tree and prepares vectors
     * for expanding the node information to obtain single hypercubes.
     * 
     * @param node_package: Nodes to be considered for a further processing.
     * 
     * Example output
     * Number of cubes per node: 4 8 8 // number_of_cubes_per_node
     * Depth per node: 5 5 5 // depth_per_node
     * Collected parent cube indices in depth 0: 90 90 90
     * Collected parent cube indices in depth 1: 3 3 3
     * Collected parent cube indices in depth 2: 1 1 1
     * Collected parent cube indices in depth 3: 1 1 1
     * Collected parent cube indices in depth 4: 3 5 7
     */
    void extract_node_information(const std::vector<Node*> &node_package);

    /** @brief Uses the vectors generated by extract_node_information to fill
     * the provided vectors containing the specific recursive search path to
     * each hypercube encoded by the respective cube indices.
     * 
     * @param node_package: Nodes to be considered for a further processing.
     * @param expanded_cube_indices: DevDat containing the expanded cube indices
     * @param expanded_depth_per_cube: Recursive depth per cube
     * Example output
     * Expanded cube indices after filling with individual cube indices in depth 0: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
     * Expanded cube indices after filling with individual cube indices in depth 1: 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
     * Expanded cube indices after filling with individual cube indices in depth 2: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
     * Expanded cube indices after filling with individual cube indices in depth 3: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
     * Expanded cube indices after filling with individual cube indices in depth 4: 3 3 3 3 5 5 5 5 5 5 5 5 7 7 7 7 7 7 7 7
     * Expanded cube indices after filling with individual cube indices in depth 5: 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
     * Expanded depth per node: 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
     */
    void expand_node_information(
        const std::vector<Node*> &node_package,
        odesolver::DevDatInt& expanded_cube_indices,
        odesolver::DimensionIteratorInt& expanded_depth_per_cube
    );

private:
    const int maximum_depth_;
    const int number_of_nodes_;

    int expected_number_of_cubes_;
    int expected_depth_;

    /** @brief List of vectors of size number_of_nodes containing the parent
     * cube indices for each node and depth. Each vector refers to a different
     * recursive depth. */
    thrust::host_vector<dev_vec_int> collected_parent_cube_indices_;
    /** @brief Vector of length number_of_nodes refering to the number of cubes
     * of each node */
    dev_vec_int number_of_cubes_per_node_;
    /** @brief Vector of length number_of_nodes containing the final depth for
     * each node */
    dev_vec_int depth_per_node_;
};

#endif //PROJECT_NODESEXPANDER_HPP
