//
// Created by lukas on 06.04.19.
//

#ifndef PROJECT_NODESEXPANDER_HPP
#define PROJECT_NODESEXPANDER_HPP

#include "../odesolver/util/header.hpp"
#include "../odesolver/util/dev_dat.hpp"
#include "../odesolver/util/monitor.hpp"
#include "node.hpp"
#include "gridcomputationwrapper.hpp"
#include "../odesolver/extern/thrust_functors.hpp"

/** @brief Class for extracting and linearizing the information about parent
 * cube indices per recursive depth per cube for the given nodes. The class
 * allows for a computation of vectors of parent cube indices and a vector of
 * the depth per cube */


class NodesExpander
{
public:
    /** @brief Constructor for extracting information about the cube indices
     * packed in each node and for preparing a computation of the vertices of
     * respective hypercubes in the recursive search tree.
     *
     * @param total_number_of_cubes: Total number of cubes encoded by the
     * provided nodes
     * @param maximum_depth: Maximum recursive depth of the provided nodes
     * @param nodes: Nodes to be considered for a further processing.
     */
    NodesExpander(
        const int total_number_of_cubes,
        const int maximum_depth,
        const std::vector<Node*> &nodes
    );

    /** @brief Extracts based on the provided nodes information about the cube
     * indices of hypercubes in the recursive search tree and prepares vectors
     * for expanding the node information to obtain single hypercubes.
     * 
     * Example output
     * Number of cubes per node: 4 8 8 // number_of_cubes_per_node
     * Depth per node: 5 5 5 // depth_per_node
     * Collected parent cube indices in depth 0: 90 90 90
     * Collected parent cube indices in depth 1: 3 3 3
     * Collected parent cube indices in depth 2: 1 1 1
     * Collected parent cube indices in depth 3: 1 1 1
     * Collected parent cube indices in depth 4: 3 5 7
     */
    void extract_node_information();

    /** @brief Uses the vectors generated by extract_node_information() to fill
     * the vectors of a GridComputationWrapper containing the specific recursive
     * search path to each hypercube encoded by the respective cube indices.
     * 
     * Example output
     * Expanded cube indices after filling with individual cube indices in depth 0: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
     * Expanded cube indices after filling with individual cube indices in depth 1: 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
     * Expanded cube indices after filling with individual cube indices in depth 2: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
     * Expanded cube indices after filling with individual cube indices in depth 3: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
     * Expanded cube indices after filling with individual cube indices in depth 4: 3 3 3 3 5 5 5 5 5 5 5 5 7 7 7 7 7 7 7 7
     * Expanded cube indices after filling with individual cube indices in depth 5: 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
     * Expanded depth per node: 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
     */
    GridComputationWrapper expand_node_information_according_to_number_of_nodes();

private:
    const size_t number_of_nodes_;
    const std::vector<Node*> &nodes_;

    const int total_number_of_cubes_;
    const int maximum_depth_;

    /** @brief List of vectors of size number_of_nodes containing the parent
     * cube indices for each node and depth. Each vector refers to a different
     * recursive depth. */
    thrust::host_vector<dev_vec_int> collected_parent_cube_indices_;
    /** @brief Vector of length number_of_nodes refering to the number of cubes
     * of each node */
    dev_vec_int number_of_cubes_per_node_;
    /** @brief Vector of length number_of_nodes containing the final depth for
     * each node */
    dev_vec_int depth_per_node_;
};

#endif //PROJECT_NODESEXPANDER_HPP
